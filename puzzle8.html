<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Puzzle 8 — Sudoku (External libs, enhanced, bugfix)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="style.css">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

  <style>
    /* Layout */
    .sudoku-page { display: flex; gap: 20px; align-items: flex-start; justify-content: center; padding: 20px; }
    .left-panel { width: 560px; }
    .right-panel { width: 260px; }

    /* Header */
    .game-header { display:flex; justify-content: space-between; align-items: center; margin-bottom:10px; color: #e6eef8; }
    .status-box { background: rgba(255,255,255,0.02); padding:8px 10px; border-radius:8px; font-weight:600; }

    /* Sudoku grid */
    .sudoku-grid {
      width: 540px; height: 540px;
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(9, 1fr);
      gap: 0;
      border: 6px solid #111;
      box-sizing: border-box;
      background: #ffffff;
    }
    .cell {
      position: relative;
      width: 100%;
      height: 100%;
      border: 1px solid rgba(0,0,0,0.12);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:28px;
      font-weight:700;
      cursor:pointer;
      background: white;
      color: #111;
      user-select:none;
    }
    .cell.given { background: #f3f4f6; color: #111; font-weight:800; cursor:default; }
    .cell.selected { background: #fde68a; }        /* selected cell */
    .cell.peer { background: #fff7cc; }            /* same row/col/box as selected */
    .cell.conflict { background: #fecaca; }        /* incorrect flash */
    .cell.same-number { background: #fb923c; color: #fff; } /* same final number (selection-based) */
    .cell.hover-same { background: #fbbf24; color: #000000; }  /* hover-based highlight (cleared separately) */

    @keyframes flashError { from { transform: scale(1.02);} to { transform: scale(1);} }

    /* Thicker boundaries between 3x3 boxes */
    .cell.col-3, .cell.col-6 { border-right: 4px solid #111; }
    .cell.col-1 { border-left: 4px solid #111; } /* left outer border */
    .cell.row-3, .cell.row-6 { border-bottom: 4px solid #111; }
    .cell.row-1 { border-top: 4px solid #111; } /* top outer border */

    /* Slight alternating shading for 3x3 boxes */
    .cell.box-shade { background: #fbfbfb; }
    .cell.box-shade.peer { background: #fff3bf; }  /* keep peer highlight visible on shaded boxes */

    /* Candidate area: 3x3 mini-grid inside each cell */
    .candidates {
      position: absolute;
      inset: 6px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      font-size:10px;
      color: #555;
      align-items:center;
      justify-items:center;
      pointer-events: none;
    }
    .candidate-dot { opacity:1; visibility:hidden; }

    /* Right-side controls */
    .controls { display:flex; flex-direction: column; gap: 10px; align-items: stretch; }
    .modes { display:flex; gap:8px; }
    .modes button { flex:1; padding:10px; border-radius:8px; border:none; font-weight:700; cursor:pointer; }
    .modes .active { background:#111; color:#fff; }
    .numpad { display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; }
    .numbtn { padding:18px; border-radius:10px; font-size:20px; font-weight:800; background:#f3f4f6; cursor:pointer; border:1px solid rgba(0,0,0,0.08); }
    .action-row { display:flex; gap:8px; margin-top:6px; }
    .action-btn { flex:1; padding:10px; border-radius:8px; cursor:pointer; font-weight:700; }

    .small { font-size:0.9rem; color: rgba(230,238,248,0.85); }

    /* locked overlay when too many errors */
    .locked-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; color: #fff; font-size:20px; z-index: 1000; border-radius:8px; }

  </style>
</head>
<body>
  <div class="sudoku-page">
    <div class="left-panel">
      <div class="game-header">
        <div class="status-box"><span id="timer">0:00</span></div>
        <div class="status-box">Errors: <span id="errors">0</span>/3</div>
      </div>

      <div id="gridContainer" style="position:relative;">
        <div id="sudokuGrid" class="sudoku-grid" aria-label="Sudoku grid"></div>
        <div id="lockedOverlay" class="locked-overlay" style="display:none;">Too many mistakes — game locked</div>
      </div>
    </div>

    <div class="right-panel">
      <div class="controls">
        <div class="modes">
          <button id="btnNormal" class="active">Normal</button>
          <button id="btnCandidate">Candidate</button>
        </div>

        <div class="small" style="margin-top:6px;">Select a cell, then select a number</div>

        <div class="numpad" style="margin-top:10px;">
          <button class="numbtn" data-val="1">1</button>
          <button class="numbtn" data-val="2">2</button>
          <button class="numbtn" data-val="3">3</button>
          <button class="numbtn" data-val="4">4</button>
          <button class="numbtn" data-val="5">5</button>
          <button class="numbtn" data-val="6">6</button>
          <button class="numbtn" data-val="7">7</button>
          <button class="numbtn" data-val="8">8</button>
          <button class="numbtn" data-val="9">9</button>
        </div>

        <div class="action-row">
          <button id="eraseBtn" class="action-btn" style="background:#ef4444;color:white;">Erase</button>
          <button id="undoBtn" class="action-btn" style="background:#6b7280;color:white;">Undo</button>
        </div>

        <div class="small" style="margin-top:10px;">
          <strong>Controls:</strong><br>
          - Toggle <em>Candidate</em> to add/remove pencil marks.<br>
          - Wrong final numbers increment the error counter. After 3 errors the game locks.
        </div>
      </div>
    </div>
  </div>

  <script>
  // ========= Easier Sudoku puzzle & solution (fixed) =========
  // I made the puzzle easier by providing the full first three rows as givens.
  const puzzle = [
    [5,3,4,6,7,8,9,1,2],  // full row given
    [6,7,2,1,9,5,3,4,8],  // full row given
    [1,9,8,3,4,2,5,6,7],  // full row given
    [8,0,0,0,6,0,0,0,3],
    [4,0,0,8,0,3,0,0,1],
    [7,0,0,0,2,0,0,0,6],
    [0,6,0,0,0,0,2,8,0],
    [0,0,0,4,1,9,0,0,5],
    [0,0,0,0,8,0,0,7,9]
  ];
  const solution = [
    [5,3,4,6,7,8,9,1,2],
    [6,7,2,1,9,5,3,4,8],
    [1,9,8,3,4,2,5,6,7],
    [8,5,9,7,6,1,4,2,3],
    [4,2,6,8,5,3,7,9,1],
    [7,1,3,9,2,4,8,5,6],
    [9,6,1,5,3,7,2,8,4],
    [2,8,7,4,1,9,6,3,5],
    [3,4,5,2,8,6,1,7,9]
  ];

  // ====== State ======
  let selected = null; // {r,c,$el}
  let candidateMode = false;
  let errorCount = 0;
  let maxErrors = 3;
  let locked = false;
  let filledCount = 0;
  let timerId = null;
  let startTime = Date.now();
  let undoStack = [];
  const candidates = new Array(9).fill(0).map(()=> Array.from({length:9}, ()=> new Set()));
  const values = puzzle.map(row => row.slice()); // current filled values (givens included)

  function cellIndex(r,c){ return r*9 + c; }
  function rcFromIndex(i){ return [Math.floor(i/9), i%9]; }
  function formatTime(s){ const mm = Math.floor(s/60).toString(); const ss = (s%60).toString().padStart(2,"0"); return mm + ":" + ss; }

  // ====== Build UI ======
  function buildGrid(){
    const $grid = $("#sudokuGrid");
    $grid.empty();
    filledCount = 0;
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        const val = puzzle[r][c];
        const idx = cellIndex(r,c);
        const $cell = $("<div>")
          .addClass("cell")
          .attr("data-r", r)
          .attr("data-c", c)
          .attr("data-idx", idx)
          .addClass("row-" + (r+1))
          .addClass("col-" + (c+1))
          .appendTo($grid);

        // apply 3x3 box shading (alternating)
        const blockRow = Math.floor(r/3), blockCol = Math.floor(c/3);
        if(((blockRow + blockCol) % 2) === 0) $cell.addClass("box-shade");

        if(val !== 0){
          $cell.addClass("given").text(val);
          filledCount++;
        } else {
          $cell.text("");
        }

        const $cand = $("<div>").addClass("candidates").appendTo($cell);
        for(let n=1;n<=9;n++){
          $("<div>").addClass("candidate-dot").attr("data-n",n).text(n).appendTo($cand);
        }

        $cell.on("click", function(){
          if(locked) return;
          selectCell($(this));
        });
      }
    }
    updateAllCandidatesUI();
    updateErrorsUI();
  }

  // ====== Selection & highlights (CLEAR both hover & previous same-number before applying) ======
  function clearHighlights(){
    $(".cell").removeClass("selected peer same-number hover-same");
  }

  function highlightPeersAndConflicts(r,c){
    // remove existing peer & same-number but keep hover-same only if it's currently used (hover handled separately)
    $(".cell").removeClass("peer same-number");

    // row
    $(`.cell[data-r=${r}]`).not(".selected").addClass("peer");
    // col
    $(`.cell[data-c=${c}]`).not(".selected").addClass("peer");
    // box
    const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
    for(let rr=br; rr<br+3; rr++){
      for(let cc=bc; cc<bc+3; cc++){
        $(`.cell[data-r=${rr}][data-c=${cc}]`).not(".selected").addClass("peer");
      }
    }

    // highlight other final-valued cells that contain the same number as selection (selection-based)
    const curVal = values[r][c];
    if(curVal && curVal !== 0){
      $(`.cell`).filter(function(){
        const rr = parseInt($(this).attr("data-r")), cc = parseInt($(this).attr("data-c"));
        if(rr===r && cc===c) return false;
        return values[rr][cc] === curVal || puzzle[rr][cc] === curVal;
      }).addClass("same-number");
    }
  }

  function selectCell($cell){
    // clear hover highlights before applying selection to avoid stuck hover-class
    $(".cell.hover-same").removeClass("hover-same");
    $(".cell.same-number").removeClass("same-number");

    $(".cell.selected").removeClass("selected");
    $cell.addClass("selected");
    selected = { r: parseInt($cell.attr("data-r")), c: parseInt($cell.attr("data-c")), $el: $cell };
    highlightPeersAndConflicts(selected.r, selected.c);
  }

  // ====== Timer ======
  function startTimer(){
    startTime = Date.now();
    $("#timer").text("0:00");
    if(timerId) clearInterval(timerId);
    timerId = setInterval(()=>{
      const s = Math.floor((Date.now()-startTime)/1000);
      $("#timer").text(formatTime(s));
    }, 1000);
  }
  function stopTimer(){ if(timerId) { clearInterval(timerId); timerId = null; } }

  // ====== Errors/Locking ======
  function updateErrorsUI(){
    $("#errors").text(errorCount);
    if(errorCount >= maxErrors){
      locked = true;
      $("#lockedOverlay").show();
      disableAllControls();
      stopTimer();
    }
  }
  function disableAllControls(){
    $(".numbtn, #eraseBtn, #undoBtn, #btnCandidate, #btnNormal").prop("disabled", true).css("opacity", 0.6);
  }

  // ====== Candidates ======
  function toggleCandidate(r,c,n){
    if(puzzle[r][c] !== 0) return;
    const set = candidates[r][c];
    if(set.has(n)) set.delete(n);
    else set.add(n);
    updateCellCandidatesUI(r,c);
  }
  function clearCandidates(r,c){
    candidates[r][c].clear();
    updateCellCandidatesUI(r,c);
  }
  function updateCellCandidatesUI(r,c){
    const $cell = $(`.cell[data-r=${r}][data-c=${c}]`);
    for(let n=1;n<=9;n++){
      const present = candidates[r][c].has(n);
      $cell.find(`.candidate-dot[data-n=${n}]`).css("visibility", present ? "visible" : "hidden");
    }
    if(values[r][c] !== 0 || puzzle[r][c] !== 0) $cell.find(".candidates").hide();
    else $cell.find(".candidates").show();
  }
  function updateAllCandidatesUI(){
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) updateCellCandidatesUI(r,c);
  }

  // ====== Place final number ======
  function placeNumber(r,c,n, recordUndo = true){
    if(locked) return;
    if(puzzle[r][c] !== 0) return;
    if(recordUndo){
      undoStack.push({ r,c, prevVal: values[r][c], prevCandidates: new Set([...candidates[r][c]]) });
      if(undoStack.length > 200) undoStack.shift();
    }
    clearCandidates(r,c);
    if(solution[r][c] === n){
      const wasEmpty = values[r][c] === 0;
      values[r][c] = n;
      const $cell = $(`.cell[data-r=${r}][data-c=${c}]`);
      $cell.text(n).addClass("filled").css("color", "#0f172a");
      if(wasEmpty) filledCount++;
      // refresh highlights
      if(selected) highlightPeersAndConflicts(selected.r, selected.c);
      if(filledCount === 81) onSolved();
      return true;
    } else {
      errorCount++;
      updateErrorsUI();
      const $cell = $(`.cell[data-r=${r}][data-c=${c}]`);
      $cell.addClass("conflict");
      setTimeout(()=> $cell.removeClass("conflict"), 350);
      return false;
    }
  }

  function eraseCell(r,c, recordUndo = true){
    if(locked) return;
    if(puzzle[r][c] !== 0) return;
    if(values[r][c] !== 0){
      if(recordUndo){
        undoStack.push({ r,c, prevVal: values[r][c], prevCandidates: new Set([...candidates[r][c]]) });
        if(undoStack.length > 200) undoStack.shift();
      }
      values[r][c] = 0;
      const $cell = $(`.cell[data-r=${r}][data-c=${c}]`);
      $cell.text("");
      filledCount = Math.max(0, filledCount - 1);
      updateCellCandidatesUI(r,c);
      if(selected) highlightPeersAndConflicts(selected.r, selected.c);
    } else {
      if(candidates[r][c].size > 0){
        if(recordUndo){
          undoStack.push({ r,c, prevVal: 0, prevCandidates: new Set([...candidates[r][c]]) });
          if(undoStack.length > 200) undoStack.shift();
        }
        clearCandidates(r,c);
      }
    }
  }

  function undo(){
    if(locked) return;
    const move = undoStack.pop();
    if(!move) return;
    const {r,c, prevVal, prevCandidates} = move;
    const currentVal = values[r][c];
    if(currentVal !== 0 && prevVal === 0) filledCount = Math.max(0, filledCount - 1);
    if(currentVal === 0 && prevVal !== 0) filledCount++;
    values[r][c] = prevVal;
    candidates[r][c] = new Set([...prevCandidates]);
    const $cell = $(`.cell[data-r=${r}][data-c=${c}]`);
    $cell.text(prevVal === 0 ? "" : prevVal);
    updateCellCandidatesUI(r,c);
    if(selected) highlightPeersAndConflicts(selected.r, selected.c);
  }

  // ====== Input handlers ======
  function onNumberClicked(n){
    if(locked) return;
    if(!selected) return;
    const r = selected.r, c = selected.c;
    if(puzzle[r][c] !== 0) return;
    if(candidateMode){
      toggleCandidate(r,c,n);
    } else {
      placeNumber(r,c,n);
    }
  }
  function onEraseClicked(){
    if(locked) return;
    if(!selected) return;
    const r = selected.r, c = selected.c;
    eraseCell(r,c);
  }
  function onCellKeyboardInput(e){
    if(locked) return;
    if(!selected) return;
    const key = e.key;
    if(key >= '1' && key <= '9') onNumberClicked(parseInt(key));
    else if(key === 'Backspace' || key === '0') onEraseClicked();
    else if(key.toLowerCase() === 'c') toggleCandidateMode();
    else if(key.toLowerCase() === 'u') undo();
  }

  function toggleCandidateMode(){
    candidateMode = !candidateMode;
    if(candidateMode){ $("#btnCandidate").addClass("active"); $("#btnNormal").removeClass("active"); }
    else { $("#btnNormal").addClass("active"); $("#btnCandidate").removeClass("active"); }
  }

  // ====== Completion handler ======
  function onSolved(){
    stopTimer();
    $(".cell").css("box-shadow", "0 0 0 4px rgba(34,197,94,0.12)");
    setTimeout(()=> { window.location.href = "complete.html"; }, 800);
  }

  // ====== Hover highlights (use separate class hover-same so selection-based same-number isn't removed) ======
  $(document).on("mouseenter", ".numbtn", function(){
    const n = parseInt($(this).attr("data-val"));
    // remove any previous hover-same first
    $(".cell.hover-same").removeClass("hover-same");
    $(".cell").filter(function(){
      const rr = parseInt($(this).attr("data-r")), cc = parseInt($(this).attr("data-c"));
      return values[rr][cc] === n || puzzle[rr][cc] === n;
    }).addClass("hover-same");
  });
  $(document).on("mouseleave", ".numbtn", function(){
    $(".cell.hover-same").removeClass("hover-same");
    // re-apply selection-based same-number if a cell is selected
    if(selected){
      highlightPeersAndConflicts(selected.r, selected.c);
    }
  });

  // ====== Setup listeners & init ======
  $(function(){
    buildGrid();
    startTimer();

    // select first empty cell or first cell
    const $firstEmpty = $(".cell").not(".given").first();
    if($firstEmpty.length) selectCell($firstEmpty);
    else selectCell($(".cell").first());

    $("#btnNormal").on("click", function(){ candidateMode = false; $("#btnNormal").addClass("active"); $("#btnCandidate").removeClass("active"); });
    $("#btnCandidate").on("click", function(){ candidateMode = true; $("#btnCandidate").addClass("active"); $("#btnNormal").removeClass("active"); });

    $(".numbtn").on("click", function(){
      const n = parseInt($(this).attr("data-val"));
      // clear any hover highlight before placing number (prevents stuck hover)
      $(".cell.hover-same").removeClass("hover-same");
      onNumberClicked(n);
      // re-highlight peers/same-number for the selected cell
      if(selected) highlightPeersAndConflicts(selected.r, selected.c);
    });

    $("#eraseBtn").on("click", function(){
      $(".cell.hover-same").removeClass("hover-same");
      onEraseClicked();
    });
    $("#undoBtn").on("click", function(){
      $(".cell.hover-same").removeClass("hover-same");
      undo();
    });

    $(document).on("keydown", onCellKeyboardInput);
    updateAllCandidatesUI();
  });
  </script>
</body>
</html>
