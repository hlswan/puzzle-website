<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Puzzle 8 — Sudoku (External libs)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Use your existing style.css for site-wide styles -->
  <link rel="stylesheet" href="style.css">

  <!-- External libs -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

  <!-- Local override / Sudoku-specific styles (kept small so you don't need to edit style.css) -->
  <style>
    /* Layout */
    .sudoku-page {
      display: flex;
      gap: 20px;
      align-items: flex-start;
      justify-content: center;
      padding: 20px;
    }
    .left-panel { width: 560px; }
    .right-panel { width: 260px; }

    /* Header (timer / errors) */
    .game-header {
      display:flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom:10px;
      color: #e6eef8;
    }
    .status-box { background: rgba(255,255,255,0.02); padding:8px 10px; border-radius:8px; font-weight:600; }

    /* Sudoku grid */
    .sudoku-grid {
      width: 540px; height: 540px;
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(9, 1fr);
      gap: 0;
      border: 6px solid #111;
      box-sizing: border-box;
      background: #f8fafc;
    }
    .cell {
      position: relative;
      width: 100%;
      height: 100%;
      border: 1px solid rgba(0,0,0,0.12);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:28px;
      font-weight:700;
      cursor:pointer;
      background: white;
      color: #111;
      user-select:none;
    }
    .cell.given { background: #f3f4f6; color: #111; font-weight:800; cursor:default; }
    .cell.selected { background: #fde68a; } /* highlight */
    .cell.error { animation: flashError 0.4s; background: #fecaca; }
    @keyframes flashError { from { transform: scale(1.02);} to { transform: scale(1);} }

    /* Thicker lines for 3x3 blocks */
    .cell.col-3, .cell.col-6 { border-right: 3px solid #333; }
    .cell.col-1, .cell.col-4, .cell.col-7 { /* nothing extra */ }
    .cell.row-3, .cell.row-6 { border-bottom: 3px solid #333; }

    /* Candidate (pencil mark) area: 3x3 mini-grid in each cell */
    .candidates {
      position: absolute;
      inset: 6px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      font-size:10px;
      color: #555;
      align-items:center;
      justify-items:center;
      pointer-events: none; /* clicks handled by .cell */
    }
    .candidate-dot { opacity:1; }

    /* Right-side controls */
    .controls {
      display:flex;
      flex-direction: column;
      gap: 10px;
      align-items: stretch;
    }
    .modes { display:flex; gap:8px; }
    .modes button { flex:1; padding:10px; border-radius:8px; border:none; font-weight:700; cursor:pointer; }
    .modes .active { background:#111; color:#fff; }
    .numpad { display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; }
    .numbtn { padding:18px; border-radius:10px; font-size:20px; font-weight:800; background:#f3f4f6; cursor:pointer; border:1px solid rgba(0,0,0,0.08); }
    .action-row { display:flex; gap:8px; margin-top:6px; }
    .action-btn { flex:1; padding:10px; border-radius:8px; cursor:pointer; font-weight:700; }

    /* small */
    .small { font-size:0.9rem; color: rgba(230,238,248,0.85); }

    /* Disabled overlay when locked */
    .locked-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.45);
      display:flex;
      align-items:center;
      justify-content:center;
      color: #fff;
      font-size:20px;
      z-index: 1000;
      border-radius:8px;
    }
  </style>
</head>
<body>
  <div class="sudoku-page">
    <div class="left-panel">
      <div class="game-header">
        <div class="status-box"><span id="timer">0:00</span></div>
        <div class="status-box">Errors: <span id="errors">0</span>/3</div>
      </div>

      <div id="gridContainer" style="position:relative;">
        <div id="sudokuGrid" class="sudoku-grid" aria-label="Sudoku grid"></div>
        <div id="lockedOverlay" class="locked-overlay" style="display:none;">Too many mistakes — game locked</div>
      </div>
    </div>

    <div class="right-panel">
      <div class="controls">
        <div class="modes">
          <button id="btnNormal" class="active">Normal</button>
          <button id="btnCandidate">Candidate</button>
        </div>

        <div class="small" style="margin-top:6px;">Select a cell, then select a number</div>

        <div class="numpad" style="margin-top:10px;">
          <button class="numbtn" data-val="1">1</button>
          <button class="numbtn" data-val="2">2</button>
          <button class="numbtn" data-val="3">3</button>
          <button class="numbtn" data-val="4">4</button>
          <button class="numbtn" data-val="5">5</button>
          <button class="numbtn" data-val="6">6</button>
          <button class="numbtn" data-val="7">7</button>
          <button class="numbtn" data-val="8">8</button>
          <button class="numbtn" data-val="9">9</button>
        </div>

        <div class="action-row">
          <button id="eraseBtn" class="action-btn" style="background:#ef4444;color:white;">Erase</button>
          <button id="undoBtn" class="action-btn" style="background:#6b7280;color:white;">Undo</button>
        </div>

        <div class="small" style="margin-top:10px;">
          <strong>Controls:</strong><br>
          - Toggle <em>Candidate</em> to add/remove pencil marks.<br>
          - Wrong final numbers increment the error counter. After 3 errors the game locks.
        </div>
      </div>
    </div>
  </div>

  <script>
  // ========= Sudoku puzzle & solution (fixed) =========
  // 0 = empty
  const puzzle = [
    [5,3,0, 0,7,0, 0,0,0],
    [6,0,0, 1,9,5, 0,0,0],
    [0,9,8, 0,0,0, 0,6,0],
    [8,0,0, 0,6,0, 0,0,3],
    [4,0,0, 8,0,3, 0,0,1],
    [7,0,0, 0,2,0, 0,0,6],
    [0,6,0, 0,0,0, 2,8,0],
    [0,0,0, 4,1,9, 0,0,5],
    [0,0,0, 0,8,0, 0,7,9]
  ];
  const solution = [
    [5,3,4,6,7,8,9,1,2],
    [6,7,2,1,9,5,3,4,8],
    [1,9,8,3,4,2,5,6,7],
    [8,5,9,7,6,1,4,2,3],
    [4,2,6,8,5,3,7,9,1],
    [7,1,3,9,2,4,8,5,6],
    [9,6,1,5,3,7,2,8,4],
    [2,8,7,4,1,9,6,3,5],
    [3,4,5,2,8,6,1,7,9]
  ];

  // ====== State ======
  let selected = null; // {r,c}
  let candidateMode = false;
  let errorCount = 0;
  let maxErrors = 3;
  let locked = false;
  let filledCount = 0; // how many final cells are filled (including givens)
  let timerId = null;
  let startTime = Date.now();
  let undoStack = [];

  // candidates: array 9x9 of Sets
  const candidates = new Array(9).fill(0).map(()=> Array.from({length:9}, ()=> new Set()));

  // current values: start from puzzle (0 means empty)
  const values = puzzle.map(row => row.slice());

  // ====== Helpers ======
  function cellIndex(r,c){ return r*9 + c; }
  function rcFromIndex(i){ return [Math.floor(i/9), i%9]; }
  function formatTime(s){
    const mm = Math.floor(s/60).toString();
    const ss = (s%60).toString().padStart(2,"0");
    return mm + ":" + ss;
  }

  // ====== Build UI ======
  function buildGrid(){
    const $grid = $("#sudokuGrid");
    $grid.empty();
    filledCount = 0;
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        const val = puzzle[r][c];
        const idx = cellIndex(r,c);
        const $cell = $("<div>")
          .addClass("cell")
          .attr("data-r", r)
          .attr("data-c", c)
          .attr("data-idx", idx)
          .addClass("row-" + (r+1))
          .addClass("col-" + (c+1))
          .appendTo($grid);

        if(val !== 0){
          $cell.addClass("given").text(val);
          filledCount++;
        } else {
          $cell.text(""); // empty
        }

        // candidates container
        const $cand = $("<div>").addClass("candidates").appendTo($cell);
        for(let n=1;n<=9;n++){
          $("<div>").addClass("candidate-dot").attr("data-n",n).text(n).appendTo($cand);
        }

        // click handler
        $cell.on("click", function(){
          if(locked) return;
          if($(this).hasClass("given")) {
            // do not select givens for input but allow selection to show highlight
            selectCell($(this));
            return;
          }
          selectCell($(this));
        });
      }
    }
    updateAllCandidatesUI();
    updateErrorsUI();
  }

  function selectCell($cell){
    $(".cell.selected").removeClass("selected");
    $cell.addClass("selected");
    selected = { r: parseInt($cell.attr("data-r")), c: parseInt($cell.attr("data-c")), $el: $cell };
  }

  // ====== Timer ======
  function startTimer(){
    startTime = Date.now();
    $("#timer").text("0:00");
    timerId = setInterval(()=>{
      const s = Math.floor((Date.now()-startTime)/1000);
      $("#timer").text(formatTime(s));
    }, 1000);
  }
  function stopTimer(){ if(timerId) { clearInterval(timerId); timerId = null; } }

  // ====== Error UI / Locking ======
  function updateErrorsUI(){
    $("#errors").text(errorCount);
    if(errorCount >= maxErrors){
      locked = true;
      $("#lockedOverlay").show();
      disableAllControls();
      stopTimer();
    }
  }

  function disableAllControls(){
    $(".numbtn, #eraseBtn, #undoBtn, #btnCandidate, #btnNormal").prop("disabled", true).css("opacity", 0.6);
    // visually disable cell input
    // selection should be prevented by locked flag
  }

  // ====== Candidate management ======
  function toggleCandidate(r,c,n){
    if(puzzle[r][c] !== 0) return; // do nothing for given
    const set = candidates[r][c];
    if(set.has(n)) set.delete(n);
    else set.add(n);
    updateCellCandidatesUI(r,c);
  }
  function clearCandidates(r,c){
    candidates[r][c].clear();
    updateCellCandidatesUI(r,c);
  }
  function updateCellCandidatesUI(r,c){
    const $cell = $(`.cell[data-r=${r}][data-c=${c}]`);
    for(let n=1;n<=9;n++){
      const present = candidates[r][c].has(n);
      $cell.find(`.candidate-dot[data-n=${n}]`).css("visibility", present ? "visible" : "hidden");
    }
    // If a final value is present, hide candidates
    if(values[r][c] !== 0 || puzzle[r][c] !== 0) $cell.find(".candidates").hide();
    else $cell.find(".candidates").show();
  }
  function updateAllCandidatesUI(){
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) updateCellCandidatesUI(r,c);
  }

  // ====== Place final number (normal mode) ======
  function placeNumber(r,c,n, recordUndo = true){
    if(locked) return;
    if(puzzle[r][c] !== 0) return; // cannot change given
    // record previous for undo
    if(recordUndo){
      undoStack.push({
        r,c,
        prevVal: values[r][c],
        prevCandidates: new Set([...candidates[r][c]])
      });
      // cap undo stack (optional)
      if(undoStack.length > 200) undoStack.shift();
    }

    // clear candidates if any
    clearCandidates(r,c);

    // check solution
    if(solution[r][c] === n){
      values[r][c] = n;
      const $cell = $(`.cell[data-r=${r}][data-c=${c}]`);
      $cell.text(n).addClass("filled").css("color", "#0f172a");
      filledCount++;
      // check completion
      if(filledCount === 81){
        // solved
        onSolved();
      }
      return true;
    } else {
      // wrong
      errorCount++;
      updateErrorsUI();
      // brief red flash
      const $cell = $(`.cell[data-r=${r}][data-c=${c}]`);
      $cell.addClass("error");
      setTimeout(()=> $cell.removeClass("error"), 300);
      return false;
    }
  }

  function eraseCell(r,c, recordUndo = true){
    if(locked) return;
    if(puzzle[r][c] !== 0) return;
    if(values[r][c] !== 0){
      if(recordUndo){
        undoStack.push({ r,c, prevVal: values[r][c], prevCandidates: new Set([...candidates[r][c]]) });
        if(undoStack.length > 200) undoStack.shift();
      }
      values[r][c] = 0;
      const $cell = $(`.cell[data-r=${r}][data-c=${c}]`);
      $cell.text("");
      filledCount = Math.max(0, filledCount - 1);
      updateCellCandidatesUI(r,c);
    } else {
      // if empty final, clear candidates
      if(candidates[r][c].size > 0){
        if(recordUndo){
          undoStack.push({ r,c, prevVal: 0, prevCandidates: new Set([...candidates[r][c]]) });
          if(undoStack.length > 200) undoStack.shift();
        }
        clearCandidates(r,c);
      }
    }
  }

  function undo(){
    if(locked) return;
    const move = undoStack.pop();
    if(!move) return;
    const {r,c, prevVal, prevCandidates} = move;
    // restore
    const currentVal = values[r][c];
    if(currentVal !== 0 && prevVal === 0) filledCount = Math.max(0, filledCount - 1);
    if(currentVal === 0 && prevVal !== 0) filledCount++;
    values[r][c] = prevVal;
    candidates[r][c] = new Set([...prevCandidates]);
    const $cell = $(`.cell[data-r=${r}][data-c=${c}]`);
    $cell.text(prevVal === 0 ? "" : prevVal);
    updateCellCandidatesUI(r,c);
  }

  // ====== Input handlers ======
  function onNumberClicked(n){
    if(locked) return;
    if(!selected) return;
    const r = selected.r, c = selected.c;
    if(puzzle[r][c] !== 0) return; // given
    if(candidateMode){
      // toggle candidate
      toggleCandidate(r,c,n);
    } else {
      // normal placement
      const ok = placeNumber(r,c,n);
      if(!ok) {
        // wrong -> nothing else
      } else {
        // correct -> update UI
      }
    }
  }

  function onEraseClicked(){
    if(locked) return;
    if(!selected) return;
    const r = selected.r, c = selected.c;
    eraseCell(r,c);
  }

  function onCellKeyboardInput(e){
    if(locked) return;
    if(!selected) return;
    const key = e.key;
    if(key >= '1' && key <= '9'){
      onNumberClicked(parseInt(key));
    } else if(key === 'Backspace' || key === '0'){
      onEraseClicked();
    } else if(key.toLowerCase() === 'c'){
      toggleCandidateMode();
    } else if(key.toLowerCase() === 'u'){
      undo();
    }
  }

  // ====== Completion handler ======
  function onSolved(){
    stopTimer();
    // small success animation or message could be added
    // redirect to complete.html after a tiny delay
    setTimeout(()=> { window.location.href = "complete.html"; }, 800);
  }

  // ====== Setup listeners ======
  $(function(){
    buildGrid();
    startTimer();

    // select first empty cell by default
    const $firstEmpty = $(".cell").not(".given").first();
    if($firstEmpty.length) selectCell($firstEmpty);

    // mode toggle
    $("#btnNormal").on("click", function(){ candidateMode = false; $("#btnNormal").addClass("active"); $("#btnCandidate").removeClass("active"); });
    $("#btnCandidate").on("click", function(){ candidateMode = true; $("#btnCandidate").addClass("active"); $("#btnNormal").removeClass("active"); });

    // number pad
    $(".numbtn").on("click", function(){
      const n = parseInt($(this).attr("data-val"));
      onNumberClicked(n);
    });

    // erase / undo
    $("#eraseBtn").on("click", onEraseClicked);
    $("#undoBtn").on("click", undo);

    // cell click selects cell (already wired in buildGrid); enable keyboard too
    $(document).on("keydown", onCellKeyboardInput);

    // update candidate visuals for all
    updateAllCandidatesUI();
  });
  </script>
</body>
</html>
